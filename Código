/**
 * Aplica un dropdown (KARLA, ITZEL, ALAN) a las columnas "Tecnico" y "Dx".
 * - Detecta las columnas por el encabezado en la fila 1.
 * - Aplica la validación desde la fila 2 hasta el final de la hoja.
 * - Permite valores en blanco (default sin color).
 */
function setDropdownTecnicoDx() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet(); // o ss.getSheetByName('NOMBRE_DE_TU_HOJA')
  
  // Encabezados a buscar (tal cual aparecen en la fila 1)
  const HEADERS = ['Tecnico', 'Dx'];
  const options = ['KARLA', 'ITZEL', 'ALAN'];

  // Leer encabezados de la fila 1
  const lastCol = sheet.getLastColumn();
  const headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0];

  // Mapa: nombre -> índice de columna (1-based)
  const colIndex = {};
  headers.forEach((h, i) => colIndex[h] = i + 1);

  // Validación: lista + permitir celdas en blanco
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(options, true)   // mostrar lista
    .setAllowInvalid(true)               // permite dejarla vacía (default)
    .build();

  const lastRow = sheet.getMaxRows(); // aplica a todas las filas disponibles

  HEADERS.forEach(name => {
    const col = colIndex[name];
    if (!col) {
      Logger.log(`No se encontró la columna "${name}".`);
      return;
    }
    // Rango desde fila 2 hasta el final de la hoja en esa columna
    const range = sheet.getRange(2, col, lastRow - 2 + 1, 1);
    range.setDataValidation(rule);
    // (Opcional) limpiar datos existentes para que queden en blanco por default:
    // range.clearContent();
  });
}


/**
 * Autoformatea la columna C (ID Orden) como "ORD-0001" al editar.
 * - Aplica solo en columna C y desde la fila 2.
 * - Si ya está en formato "ORD-####", no hace nada.
 * - Acepta números (1, 2, 10...) y los convierte a texto con ceros a la izquierda.
 */
function onEdit(e) {
  try {
    const range = e.range;
    const sheet = range.getSheet();
    if (range.getColumn() !== 3) return;      // Solo columna C
    if (range.getRow() < 1) return;           // Evita encabezados
    const val = e.value;                       // Solo funciona en edición de una celda
    if (val == null) return;

    const str = String(val).trim();

    // Si ya está en el formato correcto, salir
    if (/^ORD-\d{4}$/i.test(str)) return;

    // Si es numérico (entero positivo), formatear
    if (/^\d+$/.test(str)) {
      const num = parseInt(str, 10);
      const formatted = 'ORD-' + String(num).padStart(4, '0');
      range.setNumberFormat('@');             // Forzar "Texto"
      range.setValue(formatted);
    }
  } catch (err) {
    Logger.log(err);
  }
}

/**
 * Recorre la columna C completa (desde fila 2) y convierte números a "ORD-####".
 */
function formatearColumnaC_enLote() {
  const sheet = SpreadsheetApp.getActiveSheet(); // o getSheetByName('TuHoja')
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;

  const rng = sheet.getRange(2, 3, lastRow - 1, 1); // Columna C
  const values = rng.getValues();

  for (let i = 0; i < values.length; i++) {
    const v = values[i][0];
    if (v === '' || v == null) continue;

    const str = String(v).trim();
    if (/^ORD-\d{4}$/i.test(str)) continue;   // ya formateado
    if (/^\d+$/.test(str)) {
      const num = parseInt(str, 10);
      values[i][0] = 'ORD-' + String(num).padStart(4, '0');
    }
  }

  rng.setNumberFormat('@');
  rng.setValues(values);
}
function setDropdownColumnaD() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet(); // o ss.getSheetByName('NOMBRE_DE_TU_HOJA')

  const options = ['M', 'N', '3/4'];
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(options, true) // muestra lista
    .setAllowInvalid(true)             // permite dejar en blanco
    .build();

  const startRow = 2;                  // desde debajo de encabezados
  const col = 4;                       // columna D
  const numRows = sheet.getMaxRows() - startRow + 1;
  if (numRows <= 0) return;

  const range = sheet.getRange(startRow, col, numRows, 1);
  range.setDataValidation(rule);

  // (Opcional) Dejar en blanco todo para que quede como default vacío:
  // range.clearContent();
}
function setDropdownColumnaM() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet(); // o ss.getSheetByName('NOMBRE_DE_TU_HOJA')

  const col = 13;            // Columna M
  const startRow = 2;        // debajo de encabezados
  const numRows = sheet.getMaxRows() - startRow + 1;
  if (numRows <= 0) return;

  // 1) Data validation (dropdown). Se permite dejar en blanco.
  const options = ['Pendiente', 'Fresando', 'Listo'];
  const dvRule = SpreadsheetApp.newDataValidation()
    .requireValueInList(options, true) // muestra lista
    .setAllowInvalid(true)             // permite vacío como default
    .build();

  const rng = sheet.getRange(startRow, col, numRows, 1);
  rng.setDataValidation(dvRule);
  // (Opcional) Dejar todo en blanco para que el default sea vacío:
  // rng.clearContent();

  // 2) Formato condicional: si es "Listo" => verde.
  const rules = sheet.getConditionalFormatRules();
  const listoRule = SpreadsheetApp.newConditionalFormatRule()
    .whenTextEqualTo('Listo')
    .setBackground('#b7e1cd')          // verdosito
    .setRanges([rng])
    .build();

  // (Opcional) elimina reglas previas iguales para evitar duplicados
  const filtered = rules.filter(r => {
    const props = r.copy().build(); // no hay API directa para comparar; dejamos como simple append
    return true;                    // si te preocupa duplicados, borra reglas de la columna M antes
  });

  filtered.push(listoRule);
  sheet.setConditionalFormatRules(filtered);
}
function setCheckboxColumnaL() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet();            // o ss.getSheetByName('NOMBRE_DE_TU_HOJA')

  const col = 12;                               // Columna L
  const startRow = 2;                           // debajo del encabezado
  const numRows = sheet.getMaxRows() - startRow + 1;
  if (numRows <= 0) return;

  const range = sheet.getRange(startRow, col, numRows, 1);

  // Limpia validaciones previas y contenido (opcional)
  range.clearDataValidations();
  // range.clearContent(); // descomenta si quieres dejar todo vacío primero

  // Inserta checkboxes (palomita). Al marcar = TRUE; desmarcado = FALSE.
  range.insertCheckboxes();

  // Centrar visualmente la casilla (opcional)
  range.setHorizontalAlignment('center');
}


function setDropdownFromOtherSheet() {
  const registroFile = SpreadsheetApp.getActiveSpreadsheet();
  const registroSheet = registroFile.getSheetByName("Registro");

  // ID del archivo donde están los nombres
  const inventarioFileId = "1QjXhK5ngOglIgfaESwZDJmBLrhlVeXPkWnf7twFzBQ4";
  const inventarioFile = SpreadsheetApp.openById(inventarioFileId);
  const inventarioSheet = inventarioFile.getSheetByName("Inventario");

  // Obtiene los nombres de la columna B (omite encabezado)
  const data = inventarioSheet.getRange("B2:B").getValues().filter(String);

  // Crea la regla de validación
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(data.flat(), true)
    .setAllowInvalid(false)
    .build();

  // Aplica la validación a toda la columna G (desde la fila 2 en adelante)
  const lastRow = registroSheet.getMaxRows();
  registroSheet.getRange(`G2:G${lastRow}`).setDataValidation(rule);

  Logger.log("Dropdown aplicado correctamente");
}

/**** CONFIG ****/
const SECRETARY_SHEET_NAME = 'Diseño y Repartidor';
const SOURCE_SHEET_NAME = 'registro';   // hoja origen
const DATE_CELL = 'R1';                            // fecha del día en la hoja origen
const MASTER_SPREADSHEET_ID = '1QjXhK5ngOglIgfaESwZDJmBLrhlVeXPkWnf7twFzBQ4';
const MASTER_SHEET_NAME = 'Orders';
const TARGET_SPREADSHEET_ID = MASTER_SPREADSHEET_ID; // <-- archivo "Inventario Zirconia"
const TARGET_SHEET_NAME = 'Historial';             // hoja destino dentro de Inventario Zirconia

/***** === DEDUP + REPAIR GUARD (no tocar nombres) === *****/
const ORDER_ID_HEADER_CANDIDATES = ['ID', 'ID Orden', 'Id Orden', 'ID de orden', 'Orden', 'Order', 'ORD'];
const DISK_HEADER_CANDIDATES     = ['Disco', 'Disco/Modelo', 'Producto', 'Trabajo'];
const REPAIR_FLAG_HEADER_CANDIDATES = ['rep x. unidad', 'Rep x. unidad', 'Rep x Unidad', 'RepXUnidad', 'Rep por unidad'];

function _findHeaderIndex_(headers, candidates) {
  const lower = headers.map(h => String(h || '').trim().toLowerCase());
  for (const cand of candidates) {
    const i = lower.indexOf(String(cand).toLowerCase());
    if (i !== -1) return i;
  }
  throw new Error('No se encontró alguna de las cabeceras: ' + candidates.join(', '));
}

function _normalizeBool_(v) {
  if (typeof v === 'boolean') return v;
  if (v == null) return false;
  const s = String(v).trim().toLowerCase();
  return s === 'true' || s === 'sí' || s === 'si' || s === '1' || s === 'x';
}

function _historyKey_(orderId, disco) {
  return (String(orderId).trim() + '||' + String(disco).trim()).toLowerCase();
}

function existsInHistory_(histSheet, orderId, disco) {
  if (!orderId || !disco) return false;
  const rng = histSheet.getDataRange().getDisplayValues();
  if (rng.length <= 1) return false; // solo cabecera

  const headers = rng[0];
  const idIdx   = _findHeaderIndex_(headers, ORDER_ID_HEADER_CANDIDATES);
  const discIdx = _findHeaderIndex_(headers, DISK_HEADER_CANDIDATES);
  const wanted  = _historyKey_(orderId, disco);

  for (let r = 1; r < rng.length; r++) {
    const k = _historyKey_(rng[r][idIdx], rng[r][discIdx]);
    if (k === wanted) return true;
  }
  return false;
}

/**
 * Devuelve true si se puede insertar (nuevo o reparación).
 * Si es duplicado y NO es reparación, muestra toast y devuelve false.
 */
function guardDuplicateOrRepair_(histSheet, orderId, disco, isRepair) {
  const duplicated = existsInHistory_(histSheet, orderId, disco);
  if (duplicated && !isRepair) {
    SpreadsheetApp.getActive().toast('La orden ya está registrada, por favor verifique', 'Duplicado', 5);
    return false;
  }
  return true;
}

/** Pinta de naranja la última fila agregada al Historial (reparación). */
function colorLastRowIfRepair_(histSheet) {
  const lastRow = histSheet.getLastRow();
  const lastCol = histSheet.getLastColumn();
  if (lastRow >= 2 && lastCol >= 1) {
    histSheet.getRange(lastRow, 1, 1, lastCol).setBackground('#FCE5CD'); // naranja suave
  }
}

/**
 * Copia el registro del día al Historial.
 * Toma la fecha de R2 y la coloca en la columna A (Fecha) de cada fila pegada.
 * Omite la columna "Puente" (J) del origen porque no existe en Historial.
 * Colorea la primera fila pegada para separar días.
 */

function enviarFilaAlHistorial_(sourceSheet, rowNumber, params) {
  params = params || {};
  const histSheet = params.histSheet;
  const rowValues = params.rowValues;
  const orderId = params.orderId;
  const disco = params.disco;
  const isRepair = params.isRepair === true;

  if (!histSheet) throw new Error('No existe la hoja Historial');
  if (!rowValues) throw new Error('No hay datos para insertar');

  if (!guardDuplicateOrRepair_(histSheet, orderId, disco, isRepair)) {
    return false;
  }

  histSheet.appendRow(rowValues);
  return true;
}

function moverRegistroAHistorial() {
  const ss = SpreadsheetApp.getActive();
  const src = ss.getSheetByName(SOURCE_SHEET_NAME); // 'registro'
  if (!src) throw new Error('No existe la hoja "' + SOURCE_SHEET_NAME + '"');

  const fecha = src.getRange(DATE_CELL).getValue();
  if (!fecha) throw new Error('La celda ' + DATE_CELL + ' no tiene fecha');

  const lastRow = src.getLastRow();
  if (lastRow < 2) return; // sin datos

  const width = Math.min(15, src.getLastColumn());
  const srcHeaders = src.getRange(1, 1, 1, width).getDisplayValues()[0];
  const idIdx = _findHeaderIndex_(srcHeaders, ORDER_ID_HEADER_CANDIDATES);
  const discIdx = _findHeaderIndex_(srcHeaders, DISK_HEADER_CANDIDATES);
  const repIdx = _findHeaderIndex_(srcHeaders, REPAIR_FLAG_HEADER_CANDIDATES);

  const dataRange = src.getRange(2, 1, lastRow - 1, width);
  const values = dataRange.getValues();
  const displayValues = dataRange.getDisplayValues();

  const tss = SpreadsheetApp.openById(TARGET_SPREADSHEET_ID);
  const tgt = tss.getSheetByName(TARGET_SHEET_NAME);
  if (!tgt) throw new Error('No existe la hoja "' + TARGET_SHEET_NAME + '" en el archivo destino');

  let firstInsertedRow = null;

  for (let i = 0; i < values.length; i++) {
    const orderId = displayValues[i][idIdx];
    if (String(orderId || '').trim() === '') continue;

    const disco = displayValues[i][discIdx];
    const isRepair = _normalizeBool_(displayValues[i][repIdx]);

    const normalizedRow = [];
    for (let c = 0; c < 15; c++) {
      const value = c < values[i].length ? values[i][c] : '';
      normalizedRow[c] = (c === repIdx) ? toBool_(value) : (value === false ? '' : value);
    }

    const rowForHist = [fecha, ...normalizedRow.slice(0, 15)];

    const inserted = enviarFilaAlHistorial_(src, i + 2, {
      histSheet: tgt,
      rowValues: rowForHist,
      orderId,
      disco,
      isRepair
    });

    if (!inserted) {
      continue;
    }

    const newRowIndex = tgt.getLastRow();
    tgt.getRange(newRowIndex, 1).setNumberFormat('yyyy-mm-dd');

    if (firstInsertedRow === null) {
      firstInsertedRow = newRowIndex;
      tgt.getRange(newRowIndex, 1).setFontWeight('bold');
      tgt.getRange(newRowIndex, 1, 1, 15).setBackground('#FFF3CD');
    }

    if (isRepair) {
      colorLastRowIfRepair_(tgt);
    }
  }
}


/**
 * (Opcional) Agrega un menú para ejecutar desde el menú
 */
function onOpen() {
  try { setupRepXUnidadCheckbox_(); } catch (e) { Logger.log(e); }
  SpreadsheetApp.getUi()
    .createMenu('Registro → Historial')
    .addItem('Guardar día en Historial', 'moverRegistroAHistorial')
    .addToUi();
}

/* Opcional: si quieres LIMPIAR el registro después de copiar, descomenta:
function limpiarRegistro() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SOURCE_SHEET_NAME);
  if (!sh) return;
  const lastRow = sh.getLastRow();
  if (lastRow > 1) sh.getRange(2, 1, lastRow - 1, 15).clearContent(); // A:O
}
*/

/**
 * Limpia todos los datos de la hoja 'Registro de fresado'
 * desde la fila 2 en adelante (sin borrar encabezados ni formato).
 */
function limpiarRegistro() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('registro');
  if (!sh) throw new Error('No se encontró la hoja "Registro de fresado"');

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();

  if (lastRow > 1) {
    // Limpia contenido sin eliminar validaciones o formato
    sh.getRange(2, 1, lastRow - 1, 16).clearContent();
  }

  // Opcional: Limpia la fecha del día
  sh.getRange('R2').clearContent();

  SpreadsheetApp.getUi().alert('✅ Registro limpiado correctamente.');
}

function toBool_(v) {
  if (v === true) return true;
  if (v === false) return false;
  const s = String(v).toLowerCase();
  return s === 'true' || s === 'on' || s === '1';
}

/** Convierte letra de columna (p.ej. 'M') a índice 1-based */
function columnLetterToIndex_(letter) {
  let idx = 0;
  const up = letter.toUpperCase();
  for (let i = 0; i < up.length; i++) {
    idx = idx * 26 + (up.charCodeAt(i) - 64);
  }
  return idx;
}

/** Asegura checkbox en toda la columna (desde fila 2) */
function ensureCheckboxColumnByLetter_(sheet, letter) {
  if (!sheet) return;
  const col = columnLetterToIndex_(letter);
  const lastRow = Math.max(2, sheet.getMaxRows());
  const rng = sheet.getRange(2, col, lastRow - 1, 1);
  const rule = SpreadsheetApp.newDataValidation()
    .requireCheckbox()
    .setAllowInvalid(false)
    .build();
  rng.setDataValidation(rule);
}

/** Normaliza valores existentes TRUE/'TRUE'/1 -> true para que se vean marcados */
function normalizeTrueFalseColumn_(sheet, letter) {
  if (!sheet) return;
  const col = columnLetterToIndex_(letter);
  const last = sheet.getLastRow();
  if (last < 2) return;
  const rng = sheet.getRange(2, col, last - 1, 1);
  const vals = rng.getValues().map(r => {
    const v = r[0];
    const b = v === true || String(v).toUpperCase() === 'TRUE' || v === 1;
    return [b];
  });
  rng.setValues(vals);
}

function setupRepXUnidadCheckbox_() {
  const ss = SpreadsheetApp.getActive();
  const master = SpreadsheetApp.openById(MASTER_SPREADSHEET_ID);

  // Hojas candidatas donde aplicar checkboxes
  const sheetsToTouch = [];

  // 1) Hoja local (secretaria)
  const localSec = ss.getSheetByName(SECRETARY_SHEET_NAME);
  if (localSec) sheetsToTouch.push(localSec);

  // 2) Hoja Orders en el maestro
  const orders = master.getSheetByName(MASTER_SHEET_NAME);
  if (orders) sheetsToTouch.push(orders);

  // 3) 'registro' si existe (local o en maestro)
  const registroLocal  = ss.getSheetByName('registro');
  const registroMaster = master.getSheetByName('registro');
  [registroLocal, registroMaster].forEach(sh => { if (sh) sheetsToTouch.push(sh); });

  // Aplica en columnas K, M y N
  const letters = ['K', 'M', 'N'];

  sheetsToTouch.forEach(sh => {
    letters.forEach(letter => {
      ensureCheckboxColumnByLetter_(sh, letter);
      normalizeTrueFalseColumn_(sh, letter);
    });
  });
}

/** Pone checkbox en la columna M (desde fila 2) de la hoja ACTIVA */
function makeColumnMCheckbox() {
  const sheet = SpreadsheetApp.getActiveSheet();
  const lastRow = Math.max(2, sheet.getMaxRows());
  const range = sheet.getRange(2, 13, lastRow - 1, 1); // col 13 = M

  const rule = SpreadsheetApp.newDataValidation()
    .requireCheckbox()
    .setAllowInvalid(false)
    .build();

  range.setDataValidation(rule);
}
