 /**
 * Aplica un dropdown (KARLA, ITZEL, ALAN) a las columnas "Tecnico" y "Dx".
 * - Detecta las columnas por el encabezado en la fila 1.
 * - Aplica la validaci√≥n desde la fila 2 hasta el final de la hoja.
 * - Permite valores en blanco (default sin color).
 */
function setDropdownTecnicoDx() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet(); // o ss.getSheetByName('NOMBRE_DE_TU_HOJA')
  
  // Encabezados a buscar (tal cual aparecen en la fila 1)
  const HEADERS = ['Tecnico', 'Dx'];
  const options = ['KARLA', 'ITZEL', 'ALAN','STL'];

  // Leer encabezados de la fila 1
  const lastCol = sheet.getLastColumn();
  const headers = sheet.getRange(1, 1, 1, lastCol).getValues()[0];

  // Mapa: nombre -> √≠ndice de columna (1-based)
  const colIndex = {};
  headers.forEach((h, i) => colIndex[h] = i + 1);

  // Validaci√≥n: lista + permitir celdas en blanco
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(options, true)   // mostrar lista
    .setAllowInvalid(true)               // permite dejarla vac√≠a (default)
    .build();

  const lastRow = sheet.getMaxRows(); // aplica a todas las filas disponibles

  HEADERS.forEach(name => {
    const col = colIndex[name];
    if (!col) {
      Logger.log(`No se encontr√≥ la columna "${name}".`);
      return;
    }
    // Rango desde fila 2 hasta el final de la hoja en esa columna
    const range = sheet.getRange(2, col, lastRow - 2 + 1, 1);
    range.setDataValidation(rule);
    // (Opcional) limpiar datos existentes para que queden en blanco por default:
    // range.clearContent();
  });
}


/**
 * Autoformatea la columna C (ID Orden) como "ORD-0001" al editar.
 * - Aplica solo en columna C y desde la fila 2.
 * - Si ya est√° en formato "ORD-####", no hace nada.
 * - Acepta n√∫meros (1, 2, 10...) y los convierte a texto con ceros a la izquierda.
 */
function onEdit(e) {
  try {
    const range = e.range;
    const sheet = range.getSheet();
    if (range.getColumn() !== 4) return;      // Solo columna D
    if (range.getRow() < 1) return;           // Evita encabezados
    const val = e.value;                       // Solo funciona en edici√≥n de una celda
    if (val == null) return;

    const str = String(val).trim();

    // Si ya est√° en el formato correcto, salir
    if (/^ORD-\d{4}$/i.test(str)) return;

    // Si es num√©rico (entero positivo), formatear
    if (/^\d+$/.test(str)) {
      const num = parseInt(str, 10);
      const formatted = 'ORD-' + String(num).padStart(4, '0');
      range.setNumberFormat('@');             // Forzar "Texto"
      range.setValue(formatted);
    }
  } catch (err) {
    Logger.log(err);
  }
}

/**
 * Recorre la columna C completa (desde fila 2) y convierte n√∫meros a "ORD-####".
 */
function formatearColumnaC_enLote() {
  const sheet = SpreadsheetApp.getActiveSheet(); // o getSheetByName('TuHoja')
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return;

  const rng = sheet.getRange(2, 3, lastRow - 1, 1); // Columna C
  const values = rng.getValues();

  for (let i = 0; i < values.length; i++) {
    const v = values[i][0];
    if (v === '' || v == null) continue;

    const str = String(v).trim();
    if (/^ORD-\d{4}$/i.test(str)) continue;   // ya formateado
    if (/^\d+$/.test(str)) {
      const num = parseInt(str, 10);
      values[i][0] = 'ORD-' + String(num).padStart(4, '0');
    }
  }

  rng.setNumberFormat('@');
  rng.setValues(values);
}

function setDropdownColumnaD() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet(); // o ss.getSheetByName('NOMBRE_DE_TU_HOJA')

  const options = ['M', 'N', '3/4'];
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(options, true) // muestra lista
    .setAllowInvalid(true)             // permite dejar en blanco
    .build();

  const startRow = 2;                  // desde debajo de encabezados
  const col = 4;                       // columna D
  const numRows = sheet.getMaxRows() - startRow + 1;
  if (numRows <= 0) return;

  const range = sheet.getRange(startRow, col, numRows, 1);
  range.setDataValidation(rule);

  // (Opcional) Dejar en blanco todo para que quede como default vac√≠o:
  // range.clearContent();
}

function setDropdownColumnaM() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet(); // o ss.getSheetByName('NOMBRE-DE-TU_HOJA')

  const col = 13;            // Columna M
  const startRow = 2;        // debajo de encabezados
  const numRows = sheet.getMaxRows() - startRow + 1;
  if (numRows <= 0) return;

  // 1) Data validation (dropdown). Se permite dejar en blanco.
  const options = ['Pendiente', 'Fresando', 'Listo'];
  const dvRule = SpreadsheetApp.newDataValidation()
    .requireValueInList(options, true) // muestra lista
    .setAllowInvalid(true)             // permite vac√≠o como default
    .build();

  const rng = sheet.getRange(startRow, col, numRows, 1);
  rng.setDataValidation(dvRule);
  // (Opcional) Dejar todo en blanco para que el default sea vac√≠o:
  // rng.clearContent();

  // 2) Formato condicional: si es "Listo" => verde.
  const rules = sheet.getConditionalFormatRules();
  const listoRule = SpreadsheetApp.newConditionalFormatRule()
    .whenTextEqualTo('Listo')
    .setBackground('#b7e1cd')          // verdosito
    .setRanges([rng])
    .build();

  // (Opcional) elimina reglas previas iguales para evitar duplicados
  const filtered = rules.filter(r => {
    const props = r.copy().build(); // no hay API directa para comparar; dejamos como simple append
    return true;                    // si te preocupa duplicados, borra reglas de la columna M antes
  });

  filtered.push(listoRule);
  sheet.setConditionalFormatRules(filtered);
}

function setCheckboxColumnaL() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getActiveSheet();            // o ss.getSheetByName('NOMBRE-DE-TU_HOJA')

  const col = 12;                               // Columna L
  const startRow = 2;                           // debajo del encabezado
  const numRows = sheet.getMaxRows() - startRow + 1;
  if (numRows <= 0) return;

  const range = sheet.getRange(startRow, col, numRows, 1);

  // Limpia validaciones previas y contenido (opcional)
  range.clearDataValidations();
  // range.clearContent(); // descomenta si quieres dejar todo vac√≠o primero

  // Inserta checkboxes (palomita). Al marcar = TRUE; desmarcado = FALSE.
  range.insertCheckboxes();

  // Centrar visualmente la casilla (opcional)
  range.setHorizontalAlignment('center');
}


function setDropdownFromOtherSheet() {
  const registroFile = SpreadsheetApp.getActiveSpreadsheet();
  const registroSheet = registroFile.getSheetByName("Registro");

  if (!registroSheet) {
    Logger.log("Error: No se encontr√≥ la hoja 'Registro' en el archivo activo.");
    return;
  }

  // ID del archivo donde est√°n los nombres
  const inventarioFileId = "1QjXhK5ngOglIgfaESwZDJmBLrhlVeXPkWnf7twFzBQ4";
  let inventarioFile;
  try {
    inventarioFile = SpreadsheetApp.openById(inventarioFileId);
  } catch (e) {
    Logger.log(`Error al abrir el archivo de Inventario por ID (${inventarioFileId}): ${e}`);
    return;
  }
  
  const inventarioSheet = inventarioFile.getSheetByName("Inventario");
  if (!inventarioSheet) {
    Logger.log("Error: No se encontr√≥ la hoja 'Inventario' en el archivo de destino.");
    return;
  }

  // üîπ Obtiene los datos desde la Columna B (Discos) hasta la H (Estado)
  const inventarioLastRow = inventarioSheet.getLastRow();
  if (inventarioLastRow < 2) {
    Logger.log("No hay datos para procesar en la hoja 'Inventario'.");
    return;
  }

  // üîπ Obtenemos el rango B2:H<ultima_fila>
  // Col B = √≠ndice 0 (Disco)
  // Col H = √≠ndice 6 (Estado)
  const dataRange = inventarioSheet.getRange(`B2:H${inventarioLastRow}`).getValues();

  // Filtra los datos basado en la condici√≥n (estado en columna H)
  const filteredDiskList = dataRange.filter(row => {
    const diskName = row[0]; // Valor de la Columna B
    const status   = row[6]; // Valor de la Columna H
    
    // Incluir solo si el nombre del disco no est√° vac√≠o Y el estado cumple la condici√≥n
    return diskName !== "" && (status === "Entregado" || status === "Otro");
  }).map(row => row[0]); // Extrae solo el nombre del disco (Col B) de las filas filtradas

  
  if (filteredDiskList.length === 0) {
    Logger.log("No se encontraron discos que cumplan con la condici√≥n 'Entregado' u 'Otro'. Es posible que el dropdown aparezca vac√≠o.");
    // Opcionalmente, puedes limpiar validaciones existentes
    // const lastRow = registroSheet.getMaxRows();
    // registroSheet.getRange(`H2:H${lastRow}`).clearDataValidations();
    // return;
  }

  // Crea la regla de validaci√≥n
  const rule = SpreadsheetApp.newDataValidation()
    .requireValueInList(filteredDiskList, true) // Usa la lista ya filtrada y aplanada
    .setAllowInvalid(false)
    .build();

  // Aplica la validaci√≥n a toda la columna H (desde la fila 2 en adelante)
  const lastRow = registroSheet.getMaxRows();
  registroSheet.getRange(`H2:H${lastRow}`).setDataValidation(rule);

  Logger.log("Dropdown aplicado correctamente con filtro de estado (columna H).");
}

/**** CONFIG (SOLO DOS ARCHIVOS) ****/
const SOURCE_SHEET_NAME = 'registro';           // hoja fuente en "Registro de fresado"
const DATE_CELL = 'S1';                         // celda de fecha en la hoja fuente

// Archivo destino: "Inventario Zirconia"
const TARGET_SPREADSHEET_ID = '1QjXhK5ngOglIgfaESwZDJmBLrhlVeXPkWnf7twFzBQ4';
const TARGET_SHEET_NAME     = 'Historial';      // hoja destino dentro de "Inventario Zirconia"

/***** === DEDUP + REPAIR GUARD === *****/
const ORDER_ID_HEADER_CANDIDATES = ['ID', 'ID Orden', 'Id Orden', 'ID de orden', 'Orden', 'Order', 'ORD'];
const DISK_HEADER_CANDIDATES     = ['Disco', 'Disco/Modelo', 'Producto', 'Trabajo'];
const REPAIR_FLAG_HEADER_CANDIDATES = [
  'rep x. unidad','Rep x. unidad','Rep x Unidad','RepXUnidad','Rep por unidad',
  'rep x unidad','reparacion','reparaci√≥n','es reparacion','es reparaci√≥n'
];

/** NUEVO: Cabeceras aceptadas para el "C√≥digo de fresado" (columna Q) */
const CODIGO_FRESADO_HEADER_CANDIDATES = [
  'C√≥digo de fresado','Codigo de fresado','C√≥digo','Codigo','C√≥d. fresado','Cod fresado','C√≥d','Cod'
];

function _normalizeHeader_(s) {
  return String(s || '')
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')  // quita acentos
    .toLowerCase()
    .replace(/\s+/g, ' ')     // colapsa espacios
    .replace(/[.\-_]/g, '')   // quita puntuaci√≥n com√∫n
    .replace(/\s/g, '');      // quita espacios
}

function _findHeaderIndex_(headers, candidates) {
  const normHeaders = headers.map(h => _normalizeHeader_(h));
  const normCands   = candidates.map(c => _normalizeHeader_(c));
  for (let i = 0; i < normCands.length; i++) {
    const idx = normHeaders.indexOf(normCands[i]);
    if (idx !== -1) return idx;
  }
  throw new Error('No se encontr√≥ alguna de las cabeceras: ' + candidates.join(', '));
}

function _normalizeBool_(v) {
  if (typeof v === 'boolean') return v;
  if (v == null) return false;
  const s = String(v).trim().toLowerCase();
  return s === 'true' || s === 's√≠' || s === 'si' || s === '1' || s === 'x';
}

/** NUEVO: Llave triple ID + Disco + C√≥digo de fresado */
function _historyKey_(orderId, disco, codigoFresado) {
  return [
    String(orderId).trim(),
    String(disco).trim(),
    String(codigoFresado).trim()
  ].join('||').toLowerCase();
}

/** REEMPLAZADO: ahora compara los 3 campos */
function existsInHistory_(histSheet, orderId, disco, codigoFresado) {
  if (!orderId || !disco || !codigoFresado) return false;
  const rng = histSheet.getDataRange().getDisplayValues();
  if (rng.length <= 1) return false; // solo cabecera

  const headers = rng[0];
  const idIdx   = _findHeaderIndex_(headers, ORDER_ID_HEADER_CANDIDATES);
  const discIdx = _findHeaderIndex_(headers, DISK_HEADER_CANDIDATES);
  const codeIdx = _findHeaderIndex_(headers, CODIGO_FRESADO_HEADER_CANDIDATES);

  const wanted  = _historyKey_(orderId, disco, codigoFresado);

  for (let r = 1; r < rng.length; r++) {
    const k = _historyKey_(rng[r][idIdx], rng[r][discIdx], rng[r][codeIdx]);
    if (k === wanted) return true;
  }
  return false;
}

/**
 * REEMPLAZADO: Devuelve true si se puede insertar.
 * Bloquea solo si ID + Disco + C√≥digo de fresado ya existen.
 * (El flag de reparaci√≥n queda para pintar, no para permitir duplicados).
 */
function guardDuplicateOrRepair_(histSheet, orderId, disco, codigoFresado /*, isRepair */) {
  const duplicated = existsInHistory_(
    SpreadsheetApp.openById(TARGET_SPREADSHEET_ID).getSheetByName(TARGET_SHEET_NAME),
    orderId, disco, codigoFresado
  );
  if (duplicated) {
    SpreadsheetApp.getActive().toast('Duplicado: ID + Disco + C√≥digo de fresado ya existen.', 'Duplicado', 5);
    return false;
  }
  return true;
}

/** Pinta de naranja la √∫ltima fila agregada al Historial (reparaci√≥n). */
function colorLastRowIfRepair_(histSheet) {
  const lastRow = histSheet.getLastRow();
  const lastCol = histSheet.getLastColumn();
  if (lastRow >= 2 && lastCol >= 1) {
    histSheet.getRange(lastRow, 1, 1, lastCol).setBackground('#FCE5CD'); // naranja suave
  }
}

/**
 * Copia el registro del d√≠a al Historial.
 * Toma la fecha de DATE_CELL y la coloca en la columna A (Fecha) de cada fila pegada.
 * Omite la columna "Puente" (J) del origen porque no existe en Historial.
 * Colorea la primera fila pegada para separar d√≠as.
 */

function enviarFilaAlHistorial_(sourceSheet, rowNumber, params) {
  params = params || {};
  const histSheet     = params.histSheet;
  const rowValues     = params.rowValues;
  const orderId       = params.orderId;
  const disco         = params.disco;
  const codigoFresado = params.codigoFresado; // NUEVO
  const isRepair      = params.isRepair === true;

  if (!histSheet) throw new Error('No existe la hoja Historial');
  if (!rowValues) throw new Error('No hay datos para insertar');

  // Ahora la guardia usa los 3 campos
  if (!guardDuplicateOrRepair_(histSheet, orderId, disco, codigoFresado /*, isRepair*/)) {
    return false;
  }

  // === reemplazo de appendRow ===
  const FIRST_DATA_ROW = 2;

  // Detecta la columna clave por encabezado (ID/ID Orden/ORD-####)
  const tgtHeaders = histSheet.getRange(1, 1, 1, histSheet.getLastColumn()).getDisplayValues()[0];
  const keyColIdx1Based = _findHeaderIndex_(tgtHeaders, ORDER_ID_HEADER_CANDIDATES) + 1;

  // Lee la columna clave desde fila 2 hasta el final f√≠sico de la hoja
  const totalRows = histSheet.getMaxRows();
  const numRows = Math.max(0, totalRows - FIRST_DATA_ROW + 1);
  const keyColRange = numRows > 0 ? histSheet.getRange(FIRST_DATA_ROW, keyColIdx1Based, numRows, 1) : null;
  const keyColValues = keyColRange ? keyColRange.getValues() : [];

  // Busca la √∫ltima fila realmente ocupada (no vac√≠o)
  let lastDataIndex = -1;
  for (let i = keyColValues.length - 1; i >= 0; i--) {
    const v = keyColValues[i][0];
    if (v !== '' && v !== null) { lastDataIndex = i; break; }
  }
  const nextRow = (lastDataIndex === -1) ? FIRST_DATA_ROW : (FIRST_DATA_ROW + lastDataIndex + 1);

  // Escribe la fila en A:...
  histSheet.getRange(nextRow, 1, 1, rowValues.length).setValues([rowValues]);
  // === fin reemplazo ===

  return true;
}

function moverRegistroAHistorial() {

  const ss  = SpreadsheetApp.getActive();
  const src = ss.getSheetByName(SOURCE_SHEET_NAME);
  if (!src) throw new Error('No existe la hoja "' + SOURCE_SHEET_NAME + '"');

  const fecha = src.getRange(DATE_CELL).getValue();
  if (!fecha) throw new Error('La celda ' + DATE_CELL + ' no tiene fecha');

  const lastRow = src.getLastRow();
  if (lastRow < 2) return;

  const width = src.getLastColumn(); // NO recortar
  const srcHeaders = src.getRange(1, 1, 1, width).getDisplayValues()[0];

  const idIdx   = _findHeaderIndex_(srcHeaders, ORDER_ID_HEADER_CANDIDATES);
  const discIdx = _findHeaderIndex_(srcHeaders, DISK_HEADER_CANDIDATES);
  const repIdx  = _findHeaderIndex_(srcHeaders, REPAIR_FLAG_HEADER_CANDIDATES);
  const codIdx  = _findHeaderIndex_(srcHeaders, CODIGO_FRESADO_HEADER_CANDIDATES); // NUEVO

  const dataRange    = src.getRange(2, 1, lastRow - 1, width);
  const values       = dataRange.getValues();
  const displayVals  = dataRange.getDisplayValues();

  const tss = SpreadsheetApp.openById(TARGET_SPREADSHEET_ID);
  const tgt = tss.getSheetByName(TARGET_SHEET_NAME);
  if (!tgt) throw new Error('No existe la hoja "' + TARGET_SHEET_NAME + '" en el archivo destino');

  let firstInsertedRow = null;

  for (let i = 0; i < values.length; i++) {
    const orderId  = displayVals[i][idIdx];
    if (String(orderId || '').trim() === '') continue;

    const disco         = displayVals[i][discIdx];
    const codigoFresado = displayVals[i][codIdx];  // NUEVO
    const isRepair      = _normalizeBool_(displayVals[i][repIdx]);

    const normalized = [];
    for (let c = 0; c < width; c++) {
      const v = (c < values[i].length) ? values[i][c] : '';
      normalized[c] = (c === repIdx) ? toBool_(v) : (v === false ? '' : v);
    }

    // Ajusta el slice seg√∫n las columnas reales del Historial.
    const rowForHist = [ fecha, ...normalized.slice(0, 17) ];

    const inserted = enviarFilaAlHistorial_(src, i + 2, {
      histSheet: tgt,
      rowValues: rowForHist,
      orderId,
      disco,
      codigoFresado, // NUEVO
      isRepair
    });
    if (!inserted) continue;

    const newRowIndex = tgt.getLastRow();
    tgt.getRange(newRowIndex, 1).setNumberFormat('yyyy-mm-dd');

    if (firstInsertedRow === null) {
      firstInsertedRow = newRowIndex;
      tgt.getRange(newRowIndex, 1).setFontWeight('bold');
      tgt.getRange(newRowIndex, 1, 1, rowForHist.length).setBackground('#FFF3CD');
    }

    if (isRepair) colorLastRowIfRepair_(tgt);
  }

}


/**
 * (Opcional) Agrega un men√∫ para ejecutar desde el men√∫
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Registro ‚Üí Historial')
    .addItem('Guardar d√≠a en Historial', 'moverRegistroAHistorial')
    .addToUi();
}

/* Opcional: si quieres LIMPIAR el registro despu√©s de copiar, descomenta:
function limpiarRegistro() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SOURCE_SHEET_NAME);
  if (!sh) return;
  const lastRow = sh.getLastRow();
  if (lastRow > 1) sh.getRange(2, 1, lastRow - 1, 15).clearContent(); // A:O
}
*/

/**
 * Limpia todos los datos de la hoja 'Registro de fresado'
 * desde la fila 2 en adelante (sin borrar encabezados ni formato).
 */
function limpiarRegistro() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName('registro');
  if (!sh) throw new Error('No se encontr√≥ la hoja "registro"');

  // Ventana de advertencia/confirmaci√≥n
  const ui = SpreadsheetApp.getUi();
  const titulo = '‚ö†Ô∏è Confirmar limpieza';
  const mensaje = 'RECUERDA: Antes de limpiar se debe GUARDAR el REGISTRO y los TOTALES.\n\n'
                + 'Si ya lo hiciste, presiona "OK" para continuar con la limpieza.\n'
                + 'De lo contrario, presiona "Cancel".';
  const respuesta = ui.alert(titulo, mensaje, ui.ButtonSet.OK_CANCEL);
  if (respuesta !== ui.Button.OK) {
    ui.alert('Operaci√≥n cancelada. No se realiz√≥ ninguna limpieza.');
    return;
  }

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn(); // por si lo necesitas m√°s adelante

  if (lastRow > 1) {
    // Limpia contenido de A: P (1..16) sin afectar formato/validaciones
    sh.getRange(2, 1, lastRow - 1, 16).clearContent();

    // Limpia tambi√©n la columna Q (17) desde la fila 2 hasta la √∫ltima con datos
    sh.getRange(2, 17, lastRow - 1, 1).clearContent();
  }

  // Opcional: Limpia la fecha del d√≠a en S2
  sh.getRange('S2').clearContent();

  ui.alert('‚úÖ Registro limpiado correctamente.');
}

function toBool_(v) {
  if (v === true) return true;
  if (v === false) return false;
  const s = String(v).toLowerCase();
  return s === 'true' || s === 'on' || s === '1';
}

/** Convierte letra de columna (p.ej. 'M') a √≠ndice 1-based */
function columnLetterToIndex_(letter) {
  let idx = 0;
  const up = letter.toUpperCase();
  for (let i = 0; i < up.length; i++) {
    idx = idx * 26 + (up.charCodeAt(i) - 64);
  }
  return idx;
}

/** Asegura checkbox en toda la columna (desde fila 2) */
function ensureCheckboxColumnByLetter_(sheet, letter) {
  if (!sheet) return;
  const col = columnLetterToIndex_(letter);
  const lastRow = Math.max(2, sheet.getMaxRows());
  const rng = sheet.getRange(2, col, lastRow - 1, 1);
  const rule = SpreadsheetApp.newDataValidation()
    .requireCheckbox()
    .setAllowInvalid(false)
    .build();
  rng.setDataValidation(rule);
}

/** Normaliza valores existentes TRUE/'TRUE'/1 -> true para que se vean marcados */
function normalizeTrueFalseColumn_(sheet, letter) {
  if (!sheet) return;
  const col = columnLetterToIndex_(letter);
  const last = sheet.getLastRow();
  if (last < 2) return;
  const rng = sheet.getRange(2, col, last - 1, 1);
  const vals = rng.getValues().map(r => {
    const v = r[0];
    const b = v === true || String(v).toUpperCase() === 'TRUE' || v === 1;
    return [b];
  });
  rng.setValues(vals);
}

function prepararRepEnRegistro() {
  const sh = SpreadsheetApp.getActive().getSheetByName(SOURCE_SHEET_NAME);
  ensureCheckboxColumnByLetter_(sh, 'M');
  normalizeTrueFalseColumn_(sh, 'M');
}

/** Pone checkbox en la columna M (desde fila 2) de la hoja ACTIVA */
function makeColumnMCheckbox() {
  const sheet = SpreadsheetApp.getActiveSheet();
  const lastRow = Math.max(2, sheet.getMaxRows());
  const range = sheet.getRange(2, 13, lastRow - 1, 1); // col 13 = M

  const rule = SpreadsheetApp.newDataValidation()
    .requireCheckbox()
    .setAllowInvalid(false)
    .build();

  range.setDataValidation(rule);
}

function colorLastRowIfRepair_(histSheet, rowIndex) {
  const r = rowIndex || histSheet.getLastRow();
  const lastCol = histSheet.getLastColumn();
  if (r >= 2 && lastCol >= 1) {
    histSheet.getRange(r, 1, 1, lastCol).setBackground('#FCE5CD');
  }
}

function guardarTotalesSimpleRemoto() {
  // Origen (este archivo)
  const SRC_SHEET = 'registro';
  const DATE_CELL = 'S1';
  const VALUES_RANGE = 'T6:T16';

  // Destino (otro archivo)
  const DEST_FILE_ID = '1QjXhK5ngOglIgfaESwZDJmBLrhlVeXPkWnf7twFzBQ4';
  const DEST_SHEET = 'Totales';

  // Leer origen
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const src = ss.getSheetByName(SRC_SHEET);
  if (!src) throw new Error('No existe la hoja origen: ' + SRC_SHEET);

  const fecha = src.getRange(DATE_CELL).getValue();
  const vals = src.getRange(VALUES_RANGE).getValues().map(r => r[0]); // [v1..v6]
  const outRow = [fecha, ...vals];

  // Abrir destino
  const destFile = SpreadsheetApp.openById(DEST_FILE_ID);
  const dst = destFile.getSheetByName(DEST_SHEET);
  if (!dst) throw new Error('No existe la hoja destino: ' + DEST_SHEET);

  // Siguiente fila simple (sin formatear nada)
  const nextRow = Math.max(2, dst.getLastRow() + 1);
  dst.getRange(nextRow, 1, 1, outRow.length).setValues([outRow]);
}

function dropdownP() {
  const hoja = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const columna = hoja.getRange("P2:P"); // desde la fila 2 hasta el final
  
  // Crea una regla de validaci√≥n tipo checkbox
  const reglaCheckbox = SpreadsheetApp.newDataValidation()
    .requireCheckbox()
    .setAllowInvalid(false)
    .build();

  // Aplica la validaci√≥n a toda la columna P desde la fila 2
  columna.setDataValidation(reglaCheckbox);
  
  // Limpia los valores previos por si hay texto
  columna.clearContent();

  // Mensaje opcional en el registro de ejecuci√≥n
  Logger.log("Checklist creado correctamente en la columna P");
}
